---
title: "Fully reproducible code"
author: "Tatevik Jalatyan"
date: "5/19/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

DATA SIMULATION

```{r}
library(seqinr)
library(stringr)
library(gplots)
library(ggplot2)
```

```{r}
fileName <- "input_files/AAV_all16_new.clustal_num"
format <- "clustal"

alignment <- seqinr::read.alignment(fileName, format = format, forceToLower = F)
```

```{r}
set.seed(1)
reads_num = 300
aav_num = alignment$nb
fragment_size_min = 100 
fragment_size_max = 700 
aln_len = nchar(alignment$seq[1])


serotype_name <- c(
  "NC_002077.1",
  "NC_001401.2",  #old "ENA|J01901|J01901.1"
  "ENA|U48704|U48704.1" ,
  "NC_001829.1",
  "NC_006152.1",
  "ENA|AF028704|AF028704.1",
  "ENA|AF513851|AF513851.1",
  "ENA|AAN03857|AAN03857.1",
  "ENA|AAS99264|AAS99264.1",
  "ENA|AAT46337|AAT46337.1",
  "AY631966.1",
  "DQ813647.1",
  "EU285562.1",
  "AY242997.1", #AAVrh8
  "AY243015.1", #AAVrh10
  "AY243003.1") #AAVrh32

biased_aav_nums <- c(rep(2, 20), rep(14, 15), rep(6, 10), rep(7, 8), rep(9, 6), 
                     rep(8, 5), rep(13, 5), rep(1, 4), rep(5, 2), rep(3, 1), 
                     rep(15, 1))

seqs <- c()
seq_labels <- c()

for (i in seq(1, reads_num)){
  cursor <- 1
  seq <- ""
  seq_label_list <- c()
  
  while (cursor < aln_len) {
    
    #choose random serotype 
    sero_idx <- sample(biased_aav_nums, 1, replace=T)  #1:aav_num uniform
    #choose random cut position
    cut <- sample((cursor + fragment_size_min) : (cursor + fragment_size_max), 1, replace=F) #cursor:aln_len
    #to reduce diversity make limitation on cut positions to be divisible by 10 
    while (cut %% 100 != 0){
      cut <- sample((cursor + fragment_size_min) : (cursor + fragment_size_max), 1, replace=F)
    }

    #if cut position is near the end, take the fragment until the end
    if (aln_len - cut <= fragment_size_min){
      cut <- aln_len
    }

    #append seq, to generate the chimeric sequence
    seq <- paste0(seq, substring(alignment$seq[which(alignment$nam == serotype_name[sero_idx])], cursor, cut))  #sero_idx -> 
    #append seq_label, to keep track of the chimeric sequence composition
    seq_label_list <- c(seq_label_list, rep(sero_idx, (cut - cursor + 1)))
    
    #update cursor
    cursor <- cut
    
  }
  
  #remove gap symbols from sequence and label list
  gap_positions <- unlist(gregexpr('-', seq))
  seq <- gsub("-", "", seq)
  
  seq_label_list <- seq_label_list[- gap_positions]

  
  #change all stop codons with aa encoding codons to have long orfs 
  stop_positions <- unlist(gregexpr(seq, pattern = "TGA"))
  stop_positions <- c(stop_positions, unlist(gregexpr(seq, pattern = "TAG")))
  stop_positions <- c(stop_positions, unlist(gregexpr(seq, pattern = "TAA")))

  for (i in stop_positions){
    substr(seq, i, i) <- "C"
  }
  
  #revert the change for the last stop codon (CAA -> TAA)
  substr(seq, nchar(seq)-2, nchar(seq)-2) <- "T"
  
  #few orfs so delete 1 or 2 nts right before stop codon 
  if ((nchar(seq) %% 3) == 1){
    seq <- substring(seq, 1, nchar(seq)-4)   #remove NTAA, add TAA
    seq <- paste0(seq, "TAA")

    seq_label_list <- seq_label_list[- (length(seq_label_list) - 3)]
  } else if ((nchar(seq) %% 3) == 2){
    seq <-  substring(seq, 1, nchar(seq)-5)   #remove NNTAA, add TAA
    seq <- paste0(seq, "TAA")

    seq_label_list <- seq_label_list[- c((length(seq_label_list) - 4), (length(seq_label_list) - 3))]
  }
  
  seq_label <- paste(seq_label_list, collapse = " ")

  seqs <- c(seqs, seq)
  seq_labels <- c(seq_labels, seq_label)
}  

df <- data.frame(chimeric_seq = seqs,
                 composition = seq_labels)


df['count'] <- sample(1:50, 300, replace = T)

```


Chimeric library generation
stores in input_files/ directory

```{r}
#make chimeric library csv file
chimeric_library <- df[c('chimeric_seq', 'count', 'composition')]

chimeric_library <- as.data.frame(lapply(chimeric_library, rep, chimeric_library$count))
chimeric_library['count'] <- 1
index <- c(1:nrow(chimeric_library))
chimeric_library[, "index"] <- index
chimeric_library[, "X"] = paste0("AAV.", 100000 + as.numeric(chimeric_library$index))
chimeric_true_labels <- chimeric_library[c('X', 'composition')]

# write.csv(chimeric_true_labels, "input_files/Chimeric_lib_simulated_labels.csv", row.names = F)

chimeric_library <- chimeric_library[c('X', 'chimeric_seq','count')]
colnames(chimeric_library) <- c( 'X', 'Sequence', 'Count')

# write.csv(chimeric_library, "input_files/Chimeric_lib_simulated.csv", row.names = F)
```

Enriched library generation 

```{r}
set.seed(1)
x0 <- rnorm(1000, mean = -1, sd = 0.5)
x <- x0[x0 >= -1]
x <- sample(x, 300)
x <- round(x, 2)

enriched_count <- floor((1+x) * df$count)
df['enriched_count'] <- enriched_count
```


Figure 7 of the paper

```{r}
x_df <- data.frame(x = x0)
p1 <- ggplot(x_df, aes(x=x0)) + 
            geom_histogram(aes(y=..density..), color="black", fill="grey", binwidth = 0.1) +
            geom_density() +
            annotate("rect", xmin = -3, xmax = -1, ymin = 0, ymax = 1, alpha = .8, fill = "white") +
            xlab("Fraction change") + 
            theme_minimal()

#graphics.off()
#pdf(file.path("data_simulation_plots/percent_change_distribution.pdf"), width=8, height=5)
print(p1)
#dev.off()

```

Figure 8 of the paper

```{r}
p2 <- ggplot(df, aes(x=enriched_count)) + 
            geom_histogram(color="black", fill="grey") +
            xlab("Abundance in enriched library") + 
            ylab("Count") + 
            theme_minimal()

#graphics.off()
#pdf(file.path("data_simulation_plots/enriched_library_abundance_distribution.pdf"), width=8, height=5)
print(p2)
#dev.off()
```

```{r}
write.fastq <- function(fastq_file, output_path){
  c = 1
  while (c <= nrow(fastq_file)){
    cat(paste0("@", fastq_file$Header[c]), #, "_"
        fastq_file$Sequence[c],
        "+",
        fastq_file$Quality[c],
        sep = "\n",
        file = output_path,
        append = TRUE)
    c = c + 1
  } 
}
```

```{r}
#make enriched 1 library fastq file
enriched_library <- df[c('chimeric_seq', 'enriched_count')]
enriched_library <- as.data.frame(lapply(enriched_library, rep, enriched_library$enriched_count))
enriched_library['Quality'] <- strrep('~', nchar(enriched_library$chimeric_seq)) #highest quality score for PacBio
index <- c(1:nrow(enriched_library))
enriched_library[, "index"] <- index
enriched_library[, "Header"] = paste0("enriched.read", as.numeric(enriched_library$index))

enriched_library <- enriched_library[c('Header', 'chimeric_seq', 'Quality')]
colnames(enriched_library) <- c('Header', 'Sequence', 'Quality')

# write.fastq(enriched_library, "input_files/Enriched_lib_simulated.fastq")
# system("rm input_files/Enriched_lib_simulated.fastq.gz")
# system("gzip input_files/Enriched_lib_simulated.fastq")
```



Plots on the simulated data with true labels

```{r}
#Serotype distribution barplot on the whole chimeric library data 
s_all <- stringr::str_split(unlist(chimeric_true_labels[,'composition'], 1), " ")

col_num_all <- max(unlist(lapply(s_all, length)))
for (i in seq_len(length(s_all))){
  if (length(s_all[[i]]) < col_num_all){
    s_all[[i]] <- c(s_all[[i]], rep("18", col_num_all - length(s_all[[i]]))) #gap
  }
}

matrix_all <- matrix(as.numeric(unlist(s_all)), ncol = col_num_all, byrow = TRUE)
rownames(matrix_all) <- chimeric_true_labels[, 'X']

frequencies = matrix(nrow = nrow(matrix_all), ncol = 0)
for (i in (0:18)){
  frequencies = cbind(frequencies, rowSums(matrix_all == i))
}

colnames(frequencies) <- c("no alignment","AAV1","AAV2","AAV3","AAV4","AAV5","AAV6","AAV7","AAV8","AAV9",
                           "AAV10","AAV11","AAV12","AAV13","AAVrh8","AAVrh10","AAVrh32", "multiple alignment", "gap")
frequencies <- subset(frequencies, select = -c(gap))

frequencies_final = colSums(frequencies)
  
#Abundance of AAV serotypes in the chimeric library
serotypes_freq <- as.data.frame(frequencies_final)
colnames(serotypes_freq) <- c("Freq")
serotypes_freq['Freq(%)'] <- round(serotypes_freq$Freq*100/sum(serotypes_freq$Freq), 2)
serotypes_freq <- serotypes_freq[order(serotypes_freq$`Freq(%)`, decreasing = T), ]
print(serotypes_freq[-1])
```


Figure 3a of the paper

```{r}
  
col = c("#D3D3D3", "#A6CEE3", "#1F78B4", "#B2DF8A", "#555555", "#33A02C",
        "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", "#6A3D9A",
        "#FFFF99", "#B15928", "yellow", "#999999", "#a70000", "black", "white")
legend_name <- c("no alignment", "AAV1", "AAV2", "AAV3", "AAV4", "AAV5",
                 "AAV6", "AAV7", "AAV8", "AAV9", "AAV10", "AAV11", "AAV12", 
                 "AAV13", "AAVrh8", "AAVrh10", "AAVrh32", "multiple alignment", "gap")
col_df <- data.frame(col = col)
rownames(col_df) <- legend_name
  
  
plot.serotype.frequency <- function(serotypes_freq, col_df, library_name = ""){
  serotypes_freq['Name'] <- rownames(serotypes_freq)
  col_ordered <- col_df[serotypes_freq[order(serotypes_freq$`Freq(%)`, decreasing = T), "Name"],]
  
  p <- ggplot2::ggplot(data=serotypes_freq, 
                        aes(x=factor(Name, serotypes_freq[order(`Freq(%)`, decreasing = T), "Name"]), 
                            y=`Freq(%)`, 
                            order=`Freq(%)`)) +
          geom_bar(stat="identity", fill=col_ordered)+
          geom_text(aes(label=`Freq(%)`), vjust=-0.3, size=3.5) + 
          labs(#title=paste0("Distribution of AAV serotypes in ", library_name),
               x ="", y = "Frequency (%)") +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5)) +
          theme(axis.text.x = element_text(angle = 45, hjust = 1, size=10)) 
  print(p)
}

# graphics.off()
# pdf(file.path("data_simulation_plots/serotype_distribution_chimeric_lib_true.pdf"), width=8, height=5)
plot.serotype.frequency(serotypes_freq, col_df = col_df, library_name = "chimeric library")
# dev.off()
```

```{r}

plot.variant.description <- function(matrix, col_df, library_name = ""){
  gplots::heatmap.2(matrix, 
                    dendrogram='none', 
                    Colv=FALSE, 
                    Rowv=FALSE, #TRUE 
                    trace="none", 
                    breaks = seq(-0.5, 18.5, 1), 
                    col = col_df$col, 
                    key = FALSE, 
                    cexRow=0.7)
  title(paste0("Variant description of ", library_name), 
        line = -2, 
        adj = 0.6)
  legend(x="bottomleft", 
         legend=rownames(col_df), 
         fill=col_df$col,  
         title = "AAV serotypes", 
         title.adj = 0.2, 
         inset=c(-.07, -.07), 
         xpd=TRUE,
         box.lwd = 0, 
         cex = 0.7)

}
```


Figure 4a of the paper

```{r}
representatives <- read.csv("hafoe_out_sim_100_15/files/clstr_chimeric_lib/representatives.csv", header = F)
matrix_rep <- matrix_all[rownames(matrix_all) %in% representatives$V1,]

# graphics.off()
# pdf(file.path("data_simulation_plots/variant_description_chimeric_rep_true.pdf"), width=8, height=5)
plot.variant.description(matrix_rep, col_df = col_df,
                         library_name = "generated library \n(representatives chosen by the program)\n")
# dev.off()
```






ACCURACY COMPARISON

```{r}
get.accuracy <- function(predicted, chimeric_true_labels){
  accuracies <- c()
  for (i in predicted$X) {
    pred <- as.numeric(unlist(stringr::str_split(predicted[predicted$X == i,]$composition, " ")))
    pred <- pred[pred != 18]
    true <- as.numeric(unlist(stringr::str_split(chimeric_true_labels[chimeric_true_labels$X == i,]$composition, " ")))
  
    acc <- round(sum(pred == true)*100/length(true), 2)
    accuracies <- c(accuracies, acc)
  }
  avg_accuracy <- round(sum(accuracies)/length(accuracies))
  return(avg_accuracy)
}

chimeric_true_labels <- read.csv("input_files/Chimeric_lib_simulated_labels.csv")

```

Using accurcy files generated by tunning hafoe with corresponding read length, step size parameters

```{r}
predicted_50_50 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_50_50.csv")
predicted_50_25 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_50_25.csv")
predicted_50_15 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_50_15.csv")
predicted_50_10 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_50_10.csv")
predicted_50_5 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_50_5.csv")

predicted_100_100 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_100_100.csv")
predicted_100_75 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_100_75.csv")
predicted_100_50 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_100_50.csv")
predicted_100_25 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_100_25.csv")
predicted_100_15 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_100_15.csv")
predicted_100_10 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_100_10.csv")
predicted_100_5 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_100_5.csv")

predicted_150_150 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_150.csv")
predicted_150_125 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_125.csv")
predicted_150_100 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_100.csv")
predicted_150_75 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_75.csv")
predicted_150_50 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_50.csv")
predicted_150_25 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_25.csv")
predicted_150_15 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_15.csv")
predicted_150_10 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_10.csv")
predicted_150_5 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_150_5.csv")

predicted_200_200 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_200.csv")
predicted_200_150 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_150.csv")
predicted_200_125 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_125.csv")
predicted_200_100 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_100.csv")
predicted_200_75 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_75.csv")
predicted_200_50 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_50.csv")
predicted_200_25 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_25.csv")
predicted_200_15 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_15.csv")
predicted_200_10 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_10.csv")
predicted_200_5 <- read.csv("accuracy_files/Chimeric_rep_predicted_labels_200_5.csv")


acc_50_50 <- get.accuracy(predicted_50_50, chimeric_true_labels)
acc_50_25 <- get.accuracy(predicted_50_25, chimeric_true_labels)
acc_50_15 <- get.accuracy(predicted_50_15, chimeric_true_labels)
acc_50_10 <- get.accuracy(predicted_50_10, chimeric_true_labels)
acc_50_5 <- get.accuracy(predicted_50_5, chimeric_true_labels)

acc_100_100 <- get.accuracy(predicted_100_100, chimeric_true_labels)
acc_100_75 <- get.accuracy(predicted_100_75, chimeric_true_labels)
acc_100_50 <- get.accuracy(predicted_100_50, chimeric_true_labels)
acc_100_25 <- get.accuracy(predicted_100_25, chimeric_true_labels)
acc_100_15 <- get.accuracy(predicted_100_15, chimeric_true_labels)
acc_100_10 <- get.accuracy(predicted_100_10, chimeric_true_labels)
acc_100_5 <- get.accuracy(predicted_100_5, chimeric_true_labels)

acc_150_150 <- get.accuracy(predicted_150_150, chimeric_true_labels)
acc_150_125 <- get.accuracy(predicted_150_125, chimeric_true_labels)
acc_150_100 <- get.accuracy(predicted_150_100, chimeric_true_labels)
acc_150_75 <- get.accuracy(predicted_150_75, chimeric_true_labels)
acc_150_50 <- get.accuracy(predicted_150_50, chimeric_true_labels)
acc_150_25 <- get.accuracy(predicted_150_25, chimeric_true_labels)
acc_150_15 <- get.accuracy(predicted_150_15, chimeric_true_labels)
acc_150_10 <- get.accuracy(predicted_150_10, chimeric_true_labels)
acc_150_5 <- get.accuracy(predicted_150_5, chimeric_true_labels)

acc_200_200 <- get.accuracy(predicted_200_200, chimeric_true_labels)
acc_200_150 <- get.accuracy(predicted_200_150, chimeric_true_labels)
acc_200_125 <- get.accuracy(predicted_200_125, chimeric_true_labels)
acc_200_100 <- get.accuracy(predicted_200_100, chimeric_true_labels)
acc_200_75 <- get.accuracy(predicted_200_75, chimeric_true_labels)
acc_200_50 <- get.accuracy(predicted_200_50, chimeric_true_labels)
acc_200_25 <- get.accuracy(predicted_200_25, chimeric_true_labels)
acc_200_15 <- get.accuracy(predicted_200_15, chimeric_true_labels)
acc_200_10 <- get.accuracy(predicted_200_10, chimeric_true_labels)
acc_200_5 <- get.accuracy(predicted_200_5, chimeric_true_labels)

```


Figure 11 of the paper

```{r}
df2 <- data.frame(step_size=c("50", "25", "15", "10", "5",
                              "100", "75", "50", "25", "15", "10", "5", 
                              "150", "125", "100", "75", "50", "25", "15", "10", "5", 
                              "200", "150", "125", "100", "75", "50", "25", "15", "10", "5"),
                read_length=c(rep(50, 5),
                              rep(100, 7),
                              rep(150, 9), 
                              rep(200, 10)),
                accuracy=c(acc_50_50, acc_50_25, acc_50_15, acc_50_10, acc_50_5,
                           acc_100_100, acc_100_75, acc_100_50, acc_100_25, acc_100_15, acc_100_10, acc_100_5,
                           acc_150_150, acc_150_125, acc_150_100, acc_150_75, acc_150_50, acc_150_25, acc_150_15, acc_150_10, acc_150_5,
                           acc_200_200, acc_200_150, acc_200_125, acc_200_100, acc_200_75, acc_200_50, acc_200_25, acc_200_15, acc_200_10, acc_200_5))

library(RColorBrewer)
nb.cols <- 10
mycolors <- colorRampPalette(brewer.pal(8, "PuBu"))(nb.cols)

p <- ggplot(data=df2, aes(x=read_length, y=accuracy, 
                           fill=factor(step_size, levels = rev(c("5", "10", "15", "25", "50", "75", "100", "125", "150", "200"))))) +
        geom_bar(stat="identity", position=position_dodge2(preserve = "single")) + 
        scale_fill_manual("Step size, nt", values = mycolors) +
        labs(title=paste0(""),
                     x ="Read length, nt", y = "Accuracy (%)") +
        theme_minimal()


#graphics.off()
#pdf(file.path("data_simulation_plots/variant_description_accuracy_comparison.pdf"), width=8, height=5)
print(p)
#dev.off()

```
Extra plot, same as Figure 11 but with overlap size 

```{r}
df2 <- data.frame(overlap=c("0", "25", "35", "40", "45",
                            "0", "25", "50", "75", "85", "90", "95", 
                            "0", "25", "50", "75", "100", "125", "135", "140", "145", 
                            "0", "50", "75", "100", "125", "150", "175", "185", "190", "195"),
                read_length=c(rep(50, 5),
                              rep(100, 7),
                              rep(150, 9), 
                              rep(200, 10)),
                accuracy=c(acc_50_50, acc_50_25, acc_50_15, acc_50_10, acc_50_5,
                           acc_100_100, acc_100_75, acc_100_50, acc_100_25, acc_100_15, acc_100_10, acc_100_5,
                           acc_150_150, acc_150_125, acc_150_100, acc_150_75, acc_150_50, acc_150_25, acc_150_15, acc_150_10, acc_150_5,
                           acc_200_200, acc_200_150, acc_200_125, acc_200_100, acc_200_75, acc_200_50, acc_200_25, acc_200_15, acc_200_10, acc_200_5))


library(RColorBrewer)
nb.cols <- 20
mycolors <- colorRampPalette(brewer.pal(8, "PuBu"))(nb.cols)

p <- ggplot(data=df2, aes(x=read_length, y=accuracy, 
                           fill=factor(overlap, levels = c("0", "25", "35", "40", "45", "50", "75", 
                                                           "85", "90", "95", "100", "125", "135", "140", "145", 
                                                           "150", "175", "185", "190", "195")))) +
        geom_bar(stat="identity", position=position_dodge2(preserve = "single")) + 
        scale_fill_manual("Overlap size", values = mycolors) +
        labs(title=paste0(""),
                     x ="Read length", y = "Accuracy (%)") +
        theme_minimal() +
        theme(legend.key.size = unit(3, 'mm')) 

p

```



HAFOE

-with the parameters used to get the results of the paper
-and without external programs (the results of Bowtie2, CD-HIT, Clustal Omenga are provided)
  --the files that should be produced by these programs are used from hafoe_out_sim_100_15/ directory
  --all other output files and figures will be stored into hafoe_out_sim_100_15_new/ directory



Required input parameters

```{r}
scripts.dir <- "./src"
explore <- T
identify <- T
parent.path <- "input_files/AAV_all16_new.fasta"
chimeric.lib.path <- "input_files/Chimeric_lib_simulated.csv"
en1.path <- "input_files/Enriched_lib_simulated.fastq.gz"
output.dir <- "hafoe_out_sim_100_15_new"
output.dir.old <- "hafoe_out_sim_100_15"
read_length <- 100
overlap <- T
step_size <- 15


cat("explore =", explore, "\n")
cat("identify =", identify, "\n")
cat("scripts.dir =", scripts.dir, "\n")
cat("parent.path =", parent.path, "\n")
cat("chimeric.lib.path =", chimeric.lib.path, "\n")
cat("enriched.path =", en1.path, "\n")
cat("output.dir = ", output.dir,"\n")
cat("read_length =", read_length, "\n")
cat("overlap =", overlap, "\n")
cat("step_size =", step_size, "\n")
```


Functions used in the program

```{r}
#plot sequence length distribution histogram
plot.histogram <- function(seq_data, library_name = "", variant_orf = "", additional_info = "", bin_size = 20){
  fig <- plotly::plot_ly(x = nchar(seq_data), type = "histogram", xbins = list(size=bin_size)) 
  fig <- fig %>% layout(title= list(text = paste0(library_name, " library ", variant_orf, " length distribution", additional_info))  )
  fig
}

plot.histogram_ <- function(x, library_name = "", variant_orf = "", additional_info = "", bin_size = 20){
  fig <- plotly::plot_ly(x = x, type = "histogram", xbins = list(size=bin_size)) 
  fig <- fig %>% layout(title= list(text = paste0(library_name, " library ", variant_orf, " length distribution", additional_info)) )
  fig
}

write.fastq <- function(fastq_file, output_path){
  c = 1
  while (c <= nrow(fastq_file)){
    cat(paste0("@", fastq_file$Header[c]), 
        fastq_file$Sequence[c],
        "+",
        fastq_file$Quality[c],
        sep = "\n",
        file = output_path,
        append = TRUE)
    c = c + 1
  } 
}

#filter by minimum ORF length and max sequence length (ORF length >= min_orf (600 aa) and sequence length <= max_seq(3000))
filter.by.orf <- function(file, file_path, min_orf = 600, max_seq = 3000, format = "fasta", library_name = ""){
  cat(paste0("File: ", file_path, "\n"))
  cat(paste0("Minimum ORF length: ", min_orf, "\n"))
  cat(paste0("Maximum sequence length: ", max_seq, "\n"))
  #cat(paste0("Input file format: ", max_seq), "\n")
  cat(paste0("Number of sequences before filtering: ", nrow(file), "\n"))
  
  dna <- readDNAStringSet(file_path, format = format)
  dna_rc <- Biostrings::reverseComplement(dna)
  
  #Positive strand
  #minimumLength -> number of amino acids not bases
  pos <- findORFs(dna, longestORF = TRUE, startCodon = c("ATG"), minimumLength = min_orf)
  #Get sequences 
  gr_pos <- unlist(pos, use.names = TRUE)
  gr_pos <- GRanges(seqnames = names(dna)[as.integer(names(gr_pos))], ranges(gr_pos), strand = "+")
  names(gr_pos) <- make.names(gr_pos@ranges@NAMES, unique=TRUE)
  gr_pos_df <- as.data.frame(gr_pos)
  #Give proper names:
  #Ex. m54278_211112_013512/4391649/ccs/ORF/1706-3910/2205/+   
  names(gr_pos) <- paste0(gr_pos_df$seqnames, "/", "ORF/", gr_pos_df$start, "-", gr_pos_df$end, "/", gr_pos_df$width, "/+")
  orf_seq_pos <- Biostrings::getSeq(dna, gr_pos)
  
  orf_info_df_pos <- as.data.frame(gr_pos)
  orf_seq_df_pos <- as.data.frame(orf_seq_pos)
  
  #Negative strand
  neg <- findORFs(dna_rc, longestORF = TRUE, startCodon = c("ATG"), minimumLength = min_orf)
  if (length(neg) > 0){
  #Get sequences
    gr_neg <- unlist(neg, use.names = TRUE)
    gr_neg <- GRanges(seqnames = names(dna_rc)[as.integer(names(gr_neg))], ranges(gr_neg), strand = "-")
    names(gr_neg) <- make.names(gr_neg@ranges@NAMES, unique=TRUE)
    gr_neg_df <- as.data.frame(gr_neg)
    #Give proper names: 
    names(gr_neg) <- paste0(gr_neg_df$seqnames, "/", "ORF/", gr_neg_df$start, "-", gr_neg_df$end, "/", gr_neg_df$width, "/-")
    orf_seq_neg <- getSeq(dna_rc, gr_neg)
    
    orf_info_df_neg <- as.data.frame(gr_neg)
    orf_seq_df_neg <- as.data.frame(orf_seq_neg)
  } else {
    orf_info_df_neg <- c()
    orf_seq_df_neg <- c()
  }
  
  #Combine pos & neg
  orf_info_df_all <- rbind(orf_info_df_pos, orf_info_df_neg)
  orf_seq_df_all <-  rbind(orf_seq_df_pos, orf_seq_df_neg)
  
  #Take max ORF (group by seqname, take the row with max orf length) (some variants have multiple orfs > 1.8k)
  group <- as.data.table(orf_info_df_all, keep.rownames = TRUE)
  orf_info_df_all_max <- group[group[, .I[width == max(width)], by=seqnames]$V1]
  #Check for duplicates
  #which(duplicated(orf_info_df_all$seqnames))
  
  #Remove duplicate rows by seqname leaving only first: leave only one ORF of same variant having same length
  orf_info_df_all_max <- orf_info_df_all_max[!duplicated(orf_info_df_all_max$seqnames),]
  
  orf_seq_df_all['name'] <- rownames(orf_seq_df_all)
  orf_seq_df_all_max <- orf_seq_df_all[rownames(orf_seq_df_all) %in% orf_info_df_all_max$rn,]
  
  #Contains orfs
  fasta_orf_seq <- orf_seq_df_all_max[c('name', 'x')]
  colnames(fasta_orf_seq) <- c("Header", "Sequence")
  
  #Contains original sequences
  fasta_orf <- dplyr::inner_join(file, orf_info_df_all_max, by = c("Header" = "seqnames")) 
  fasta_orf <- fasta_orf[c('rn', 'Sequence')]  
  colnames(fasta_orf) <- c('Header', 'Sequence')
  
  #Filter by sequence length (max_seq)
  fasta_orf_filtered <- fasta_orf[nchar(fasta_orf$Sequence) <= max_seq, ] 
  fasta_orf_seq_filtered <- fasta_orf_seq[fasta_orf_seq$Header %in% fasta_orf_filtered$Header,]
  
  #Store filtered orf sequences into fasta file
  writeFasta(fasta_orf_seq_filtered, file.path(output.dir, "files", paste0(library_name, "_ORF.fasta")))
  
  if (format == "fastq"){
    #Add sequence original name, orf start, end positions as columns
    orf_seq_df_all_max$name_original <- sub("/ORF.*", "", orf_seq_df_all_max$name)
    ranges <- str_split(orf_seq_df_all_max$name, pattern = "/", simplify = TRUE)[,3]  #[,5]
    start <- str_split(ranges, pattern = "-", simplify = TRUE)[,1]
    end <- str_split(ranges, pattern = "-", simplify = TRUE)[,2]
    orf_seq_df_all_max['start'] <- start
    orf_seq_df_all_max['end'] <- end
    
    #Contains orfs
    fastq_orf_seq <- inner_join(file, orf_seq_df_all_max, by = c("Header" = "name_original")) 
    fastq_orf_seq['quality_orf'] <- substring(fastq_orf_seq$Quality, fastq_orf_seq$start, fastq_orf_seq$end)
    fastq_orf_seq <- fastq_orf_seq[c('name', 'x', 'quality_orf')]  
    colnames(fastq_orf_seq) <- c('Header', 'Sequence', 'Quality')
    
    fastq_orf_seq_filtered <- fastq_orf_seq[fastq_orf_seq$Header %in% fasta_orf_filtered$Header,]
    
    # write.fastq(fastq_file = fastq_orf_seq_filtered, 
    #             output_path = file.path(output.dir, "files", paste0(library_name, "_ORF.fastq")))
    
  }
  
  #Store dataframe outputs in list (for plotting histogram)
  out <- list(fasta_orf_filtered, fasta_orf_seq_filtered)      
  
  cat(paste0("Number of sequences after filtering: ", nrow(fasta_orf_seq_filtered), "\n"))
  cat("ORF length summary statistics\n")
  print(summary(nchar(fasta_orf_seq_filtered$Sequence)))
  cat("\n")
  
  return(out)
}

choose.new.representatives <- function(sizes_path, members_path, chimeric_library, fasta_orf_seq_filtered_chim, fasta_path, csv_path){
  cat("Choosing a new representative ORF sequence for each cluster based on: \n")
  cat("\t1. greatest sequence abundance in the input chimeric library\n")
  cat("\t2. maximum ORF length\n")
  cat(paste0("Output path: ", fasta_path, "\n"))

  #use the generated members_ordered.csv and sizes.csv to separate variants by clusters
  sizes <- read.csv(sizes_path, header = FALSE)
  sizes['sum'] <- cumsum(sizes$V1)
  members <- read.csv(members_path, header = FALSE)

  #for each cluster choose a representative sequence (1.max count, 2.max ORF length)
  #for loop which works for each cluster
  for (i in seq_len(nrow(sizes))){
    #only for 1st cluster
    if (i == 1){
      #make dataframe containing only the variants which are in the 1st cluster (cluster 0)
      #example of a variant name: AAV.211507/ORF/754-2958/2205/-      I split by / to get   AAV.211507  ORF  754-2958  2205  -     this info in separate columns, to be able to use width/length of orfs
      temp <- as.data.frame(stringr::str_split(members[1:sizes$sum[1],], pattern = "/", simplify = TRUE))
      colnames(temp) <- c("name", "ORF", "pos", "width", "strand")
      #join to initial data by variant name to also take the count column
      temp <- dplyr::inner_join(temp, chimeric_library[c('X', 'Count')],  by = c("name" = "X"))
      #take only the row(s)/variant(s) having max count
      max_count <- temp[temp$Count == max(temp$Count),]
      #from them take only the row(s)/variant(s) having max orf length
      max_width <- max_count[max_count$width == max(max_count$width),]
      #make a dataframe rep containing cluster number, representative's name, its orf length and abundance count
      rep <- data.frame(Cluster = i-1,
                        Representative = max_width[1, 'name'], #[1,'name'] 1 means I take only 1st row just in case multiple having max count
                        Width = max_width[1,'width'],
                        Count = max_width[1, 'Count'])
      #make df of cluster members
      cluster_members <- data.frame(Cluster = i-1,
                                    Representative = max_width[1, 'name'])
      cluster_members$Members <- list(temp$name)
    }
    #for the rest of clusters
    else{
      #same thing for the rest of clusters (cluster 1, then cluster 2, etc.)
      temp <- as.data.frame(stringr::str_split(members[(sizes$sum[i-1]+1) : sizes$sum[i], ],
                                            pattern = "/", simplify = TRUE))
      colnames(temp) <- c("name", "ORF", "pos", "width", "strand")
      temp <- dplyr::inner_join(temp, chimeric_library[c('X', 'Count')],  by = c("name" = "X"))
      max_count <- temp[temp$Count == max(temp$Count),]
      max_width <- max_count[max_count$width == max(max_count$width),]
      #populates the dataframe rep created above for the 1st cluster
      rep <- rbind(rep,
                   c(i-1,
                     max_width[1, 'name'],
                     max_width[1, 'width'],
                     max_width[1, 'Count']))
      
      cluster_members <- rbind(cluster_members,
                               c(i-1,
                                 max_width[1, 'name'],
                                 NA))
      cluster_members$Members[i] <- list(temp$name)
      
    }
  }
  
  #from initial fasta file take only the representative variants
  fasta_orf_seq_filtered_names <- stringr::str_split(fasta_orf_seq_filtered_chim$Header, pattern = "/", simplify = TRUE)[,1]
  
  rep_fasta <- fasta_orf_seq_filtered_chim[fasta_orf_seq_filtered_names %in% rep$Representative,]
  
  #create a new fasta file containing representatives
  microseq::writeFasta(rep_fasta,
                       fasta_path)
  write.table(rep$Representative,
              csv_path,
              row.names = F,
              col.names = F,
              quote = F,
              sep = ",")
  return(cluster_members)
}

#change based on fastq file
make.fastq.files <- function(read_length, fasta.path, library_name = "", overlap = F, step_size = read_length){
  cat("Chopping each representative sequence into fragments of fixed size and storing into fastq files \n")
  cat(paste0("Fragment length: ", read_length, "\n"))
  cat(paste0("Use overlapping fragments (TRUE/FALSE): ", overlap, "\n"))
  if (overlap == F){
    step_size = read_length
  } 
    cat(paste0("Step size: ", step_size, "\n"))
  cat(paste0("Output path: ", file.path(output.dir, "files/variant_description", library_name, "fastq"), "\n"))
  if (step_size > read_length){
    cat("Warning: step size is greater than fragment length, some regions of the sequence will be skipped!")
  }

  data <- microseq::readFasta(fasta.path)  
  data$name <- matrix(unlist(stringr::str_split(data$Header, "/")), ncol = 5, byrow = TRUE)[,1]
  
  dir.create(file.path(output.dir, "files/variant_description"), showWarnings = F)
  dir.create(file.path(output.dir, "files/variant_description", library_name), showWarnings = F)
  dir.create(file.path(output.dir, "files/variant_description", library_name, "fastq"), showWarnings = F)
  splitter <- function(rl, ss, c){
    pos = 0     
    read_counter = 10001 #10^nchar(as.character(ceiling(max(nchar(data$Sequence))/ss)))+1
    
    # GENERAL CASE
    while(pos < nchar(data[c, "Sequence"])){  #fragments of length less than rl may be generated at the end of the sequence
      cat(paste0("@", data[c, "Header"], "_", read_counter),
          substring(data[c, "Sequence"], pos + 1, pos + as.numeric(rl)),
          "+",
          strrep("h", nchar(substring(data[c, "Sequence"], pos + 1, pos + as.numeric(rl)))),
          sep = "\n",
          file = file.path(output.dir, "files/variant_description", library_name, "fastq",
                           paste0(data[c,"name"], ".fastq")),
          append = TRUE)
      pos = pos + as.numeric(ss)
      read_counter = read_counter + 1
    }
  }
  
  c = 1
  while (c <= nrow(data)){
    splitter(read_length, step_size, c)
    c = c + 1
  }
}



#parents_df change general case from parents fasta or separate input paramenter from .sh
neighbor.joining <- function(parents_df, path_fasta, path_mapped, path_unmapped, read_length, library_name = "", overlap = F, step_size = read_length){
  cat(paste0("Output path: ", file.path(output.dir, 
                                        "files/variant_description", 
                                        library_name, 
                                        paste0(library_name, "_variant_description.csv")), "\n"))
  
  if (overlap == F){
    step_size = read_length
  }
  
  #make directory for output file if not created yet
  dir.create(file.path(output.dir, "files/variant_description"), showWarnings = F)
  dir.create(file.path(output.dir, "files/variant_description", library_name), showWarnings = F)
  
  data <- microseq::readFasta(path_fasta)  
  
  #path_mapped - path of directory containing csv files generated from bam files(only mapped reads). 
  #In these csv files there are 2 columns(read name and serotype name)
  
  #list of file names in that directory
  files_mapped <- list.files(path = path_mapped, pattern = "\\.csv$", full.names = FALSE, ignore.case = TRUE)
  
  #path_unmapped - path of directory containing csv files generated from fastq files(only unmapped reads). 
  #In these csv files there is 1 column(read name)
  
  #list of file names in that directory
  files_unmapped <- list.files(path = path_unmapped, pattern = "\\.csv$", full.names = FALSE, ignore.case = TRUE)
  
  files_names <- sub('\\.csv$', '', list.files(path = path_mapped, pattern = "\\.csv$", full.names = FALSE, ignore.case = TRUE))
  #binds these two lists of files by column (resulting 2 column and each row corresponding to one variant). Needed to connect mapped and unmapped files for each variant
  file_pairs = cbind(files_mapped, files_unmapped, files_names)  

  isEmpty <- function(x) {
    return(length(x)==0)
  }
  
  
  #empty matrix which will be filled in the for loop
  m <- matrix(data=list(),
              nrow=nrow(file_pairs),
              ncol=2)
  read <- c()
  options <- list()
  
  #for loop iterating over all query variants' mapped and unmapped files simultaneously 
  for (j in seq_len(nrow(file_pairs))) {
    
    #there where some empty files in mapped and unmapped files, so I used if/else statements to ignore them
    #MAPPED
    if (file.size(file.path(path_mapped, file_pairs[[j, 1]])) > 0){
      
      #open csv file, do not use first row as header, use tab to seperate columns. read as matrix
      data_mapped <- as.matrix(read.csv(file.path(path_mapped, 
                                                  file_pairs[[j, 1]]), 
                                        header = F, 
                                        sep = "\t"))
      #specify column names of matrix
      colnames(data_mapped) <- c("variant_read", "serotype")
      
      #extract read numbers from the first column of data_mapped matrix (ex: AAV.100001.1003 --> 3)
      #read_num <- as.numeric(substring(data_mapped[,1], nchar(data_mapped[,1])-4+1, nchar(data_mapped[,1]))) - 1000
      read_num <- as.numeric(substring(data_mapped[,1], 
                                       nchar(data_mapped[,1]) - 5 + 1, 
                                       nchar(data_mapped[,1]))) - 10000
      
      #add this list of read numbers to data_mapped matrix as a column
      data_mapped <- cbind(data_mapped, read_num)
    } else {
      read_num <- c(-1)
    }
    
    #UNMAPPED
    #if file not empty
    if (file.size(file.path(path_unmapped, file_pairs[[j, 2]])) > 0){ 
      #same for unmapped files
      data_unmapped <- as.matrix(read.csv(file.path(path_unmapped, file_pairs[[j, 2]]), 
                                          header = F, 
                                          sep = "\t"))  
      
      colnames(data_unmapped) <- c("variant_read")
      
      #read_num_un <- as.numeric(substring(data_unmapped[,1], nchar(data_unmapped[,1])-4+1, nchar(data_unmapped[,1]))) - 1000
      read_num_un <- as.numeric(substring(data_unmapped[,1], 
                                          nchar(data_unmapped[,1])- 5 + 1, 
                                          nchar(data_unmapped[,1]))) - 10000
    } else {
      read_num_un <- c(-1)
    }
    
    #empty vector to be filled in the for loop
    v = list()
    #for loop iterates over read numbers of corresponding variant 
    for (i in 1: max(max(read_num), max(read_num_un))) {
      #if the number of reads is present in the read_num list (list for mapped reads)
      if (i %in% read_num) {
        #then the vector v is appended by the serotype number in corresponding position 
        s <- data_mapped[data_mapped[,"read_num"] == i, "serotype"]
        v[[i]] <- parents_df[serotype_name %in% s, "serotype_num"]
        
      }
      #if the number of reads is present in the read_num_un list(list for unmapped reads)
      if (i %in% read_num_un) {
        #then  the vector v is appended by 0 in corresponding position 
        v[[i]] = 0 
      } 
    }
    
    ###neighbor-aware serotype identification
    
    s <- 1
    while(s > 0){
      
      for (i in 1:(length(v)-1)){
        #if there is intersect and they are not the same assign   the intersect to both neighbors
        if((!isEmpty(intersect(v[[i]], v[[i+1]]))) && (!setequal(v[i], v[i+1]))){
          v[[i]] = intersect(v[[i]], v[[i+1]])
          v[[i+1]] = intersect(v[[i]], v[[i+1]])
        }
      }
      
      s <- 0
      for (i in 1:(length(v)-1)){
        if( !setequal(v[i], v[i+1]) ) {
          s <- s + !isEmpty(intersect(v[[i]], v[[i+1]]))
        }
      }
    }
    
    
    for (i in 1:length(v)){
      if (length(v[[i]]) > 1){
        read = append(read, paste(substring(data_mapped[[1,1]], 1, nchar(data_mapped[1,1])- 5 + 1), "_", as.character(1000+i), sep = "") )
        options[[length(read)]] = v[[i]]
        
        v[[i]] <- 17
      }
    }
    
    
    #after the vector v is made, the empty matrix mat defined above is appended. 1st column is the name of variant,
    #2nd column is a string of serotype numbers separated by spaces
    m[[j, 1]] <- file_pairs[[j, 3]]

    m[[j, 2]] <- paste(v, collapse = " ")
    
  }
  

  s <- stringr::str_split(unlist(m[,2], 1), " ")
  col_num <- ceiling(max(nchar(data$Sequence))/step_size)
  for (i in seq_len(length(s))){
    if (length(s[[i]]) < col_num){ #23
      s[[i]] <- c(s[[i]], rep("18", col_num - length(s[[i]]))) #gap
    }
  }
  
  m_new <- matrix(as.numeric(unlist(s)), ncol = col_num, byrow = TRUE)
  rownames(m_new) <- m[,1]
  
  write.table(m_new, 
              file.path(output.dir, 
                        "files/variant_description", 
                        library_name, 
                        paste0(library_name, "_variant_description.csv")), 
              quote = F, 
              col.names = F)
  
}


plot.cluster.size.distribution <- function(cluster_members, size_thresh, library_name = ""){
  cluster_members["Size"] <- unlist(lapply(cluster_members$Members, length))
  data <- cluster_members[-3]
  data <- data[data$Size > size_thresh,]
  
  p <- ggplot2::ggplot(data=data, 
                      aes(x=factor(Representative, data[order(Size, decreasing = T), "Representative"]), 
                          y=Size, 
                          order=Size)) +
        geom_bar(stat="identity")+
        geom_text(aes(label=Size), vjust=-0.3, size=2) +
        labs(title=paste0("Cluster size distribution in ", library_name, "\n(Cluster size > ", size_thresh, ")"),
             x ="", y = "Cluster size") +
        theme_minimal() +
        theme(plot.title = element_text(hjust = 0.5)) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5)) 
  print(p)
}



plot.variant.description <- function(matrix, col_df, library_name = ""){
  gplots::heatmap.2(matrix, 
                    dendrogram='none', 
                    Colv=FALSE, 
                    Rowv=FALSE, #TRUE 
                    trace="none", 
                    breaks = seq(-0.5, 18.5, 1), 
                    col = col_df$col, 
                    key = FALSE, 
                    cexRow=0.7)
  title(paste0("Variant description of ", library_name), 
        line = -2, 
        adj = 0.6)
  legend(x="bottomleft", 
         legend=rownames(col_df), 
         fill=col_df$col,  
         title = "AAV serotypes", 
         title.adj = 0.2, 
         inset=c(-.07, -.07), 
         xpd=TRUE,
         box.lwd = 0, 
         cex = 0.7)

}


plot.variant.description.conserved <- function(matrix,  col_df, identity_ranges, library_name = ""){
  gplots::heatmap.2(matrix, 
                    dendrogram='none', 
                    Colv=FALSE, 
                    Rowv=TRUE, 
                    trace="none", 
                    breaks = seq(-0.5, 18.5, 1),
                    col = col_df$col,
                    key = FALSE, 
                    cexRow=0.7,
                    add.expr = list(rect(xleft = identity_ranges$start_nt, 
                                         xright = identity_ranges$end_nt, 
                                         ybottom = par("usr")[3], ytop = par("usr")[4], 
                                         border = NA, 
                                         col = adjustcolor("blue", alpha = 0.2)),
                                    rect(xleft = aav2_vr_ranges$start_nt,   #VRs
                                         xright = aav2_vr_ranges$end_nt, 
                                         ybottom = par("usr")[3], ytop = par("usr")[4], 
                                         border = NA, 
                                         density = 20, 
                                         col = adjustcolor("red", alpha = 0.5))))
  
  title(paste0("Variant description of ", library_name), 
        line = -2, 
        adj = 0.6)
  legend(x="bottomleft", 
         legend=rownames(col_df), 
         fill=col_df$col,  
         title = "AAV serotypes", 
         title.adj = 0.2, 
         inset=c(-.07, -.07), 
         xpd=TRUE,
         box.lwd = 0, 
         cex = 0.7)
}



get.frequency.table <- function(chimeric_library, nj_matrix, cluster_members, output_path){
  #combined counts of chimeric lib representatives
  counts_chim <- data.frame(Representative = NA, 
                            Chimeric.Count = NA)
  
  for (rep in cluster_members$Representative){
    s <- sum(chimeric_library[chimeric_library$X %in% unlist(cluster_members$Members[cluster_members$Representative == rep]), c('Count')])
    counts_chim <- rbind(counts_chim, c(rep, s))
  }
  
  counts_chim <- na.omit(counts_chim)
  counts_chim$Chimeric.Count <- as.numeric(counts_chim$Chimeric.Count)
  
  counts_chim['Chimeric.Percentage'] <- round((100 * (counts_chim$Chimeric.Count / sum(counts_chim$Chimeric.Count))), 2)
  counts_chim <- counts_chim %>% arrange(desc(Chimeric.Count))
  
  write.csv(counts_chim, file.path(output_path, "chimeric_lib_rep_counts.csv"), row.names = FALSE, quote = F)
  
  #serotype frequencies per representative variant
  frequencies = matrix(nrow = nrow(nj_matrix), ncol = 0)
  for (i in (0:18)){
    frequencies = cbind(frequencies, rowSums(nj_matrix == i))
  }
  
  #serotype freq * representative combined count
  frequencies_with_count = matrix(nrow = 0, ncol = ncol(frequencies))
  for (i in rownames(frequencies)){
    frequencies_with_count = rbind(frequencies_with_count, 
                                   counts_chim[counts_chim$Representative == i, "Chimeric.Count"] * frequencies[i,])
  }
  
  frequencies_with_count_df = as.data.frame(frequencies_with_count)
  colnames(frequencies_with_count_df) <- c("no alignment","AAV1","AAV2","AAV3","AAV4","AAV5","AAV6","AAV7","AAV8","AAV9",
                                          "AAV10","AAV11","AAV12","AAV13","AAVrh8","AAVrh10","AAVrh32", "multiple alignment", "gap")
  rownames(frequencies_with_count_df) <- rownames(frequencies)
  
  frequencies_with_count_df <- subset(frequencies_with_count_df, select = -c(gap))
  
  write.csv(frequencies_with_count_df, file.path(output_path, "chimeric_lib_serotype_counts.csv"), quote = F)
  
  #for all representatives
  frequencies_final = colSums(frequencies_with_count_df)
  
  #summary frequency table
  cat("\nAbundance of AAV serotypes in the chimeric library\n")
  serotypes_freq <- as.data.frame(frequencies_final)
  colnames(serotypes_freq) <- c("Freq")
  serotypes_freq['Freq(%)'] <- round(serotypes_freq$Freq*100/sum(serotypes_freq$Freq), 2)
  serotypes_freq <- serotypes_freq[order(serotypes_freq$`Freq(%)`, decreasing = T), ]
  print(serotypes_freq[-1])
  
  return(serotypes_freq)
}




plot.serotype.frequency <- function(serotypes_freq, col_df, library_name = ""){
  serotypes_freq['Name'] <- rownames(serotypes_freq)
  col_ordered <- col_df[serotypes_freq[order(serotypes_freq$`Freq(%)`, decreasing = T), "Name"],]
  
  p <- ggplot2::ggplot(data=serotypes_freq, 
                        aes(x=factor(Name, serotypes_freq[order(`Freq(%)`, decreasing = T), "Name"]), 
                            y=`Freq(%)`, 
                            order=`Freq(%)`)) +
          geom_bar(stat="identity", fill=col_ordered)+
          geom_text(aes(label=`Freq(%)`), vjust=-0.3, size=3.5) + 
          labs(title=paste0("Distribution of AAV serotypes in ", library_name),
               x ="", y = "Frequency (%)") +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5)) +
          theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
  print(p)
}
  

plot.cluster.abundance <- function(file_path, size_thresh, library_name = ""){
  data = read.csv(file_path)
  data <- data[data$Chimeric.Count > size_thresh,]
  
  p <- ggplot2::ggplot(data=data, 
                        aes(x=factor(Representative, data[order(Chimeric.Count, decreasing = T), "Representative"]), 
                            y=Chimeric.Count, 
                            order=Chimeric.Count)) +
          geom_bar(stat="identity")+
          geom_text(aes(label=Chimeric.Count), vjust=-0.3, size=2) +
          labs(title=paste0("Cluster abundance in ", library_name, "\n(Combined count > ", size_thresh, ")"),
               x ="", y = "Combined count of variants") +
          theme_minimal() +
          theme(plot.title = element_text(hjust = 0.5)) +
          theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5)) 
  
  print(p)
}

get.counts.table <- function(chim_file_path, output_path_old, output_path){
  counts_chim = read.csv(chim_file_path)
  
  sizes_en1 <- read.csv(file.path(output_path_old,"clstr_enriched1_lib/cluster_sizes.csv"), header = FALSE)
  sizes_en1$V1 <- sizes_en1$V1 - 1
  sizes_en1['sum'] <- cumsum(sizes_en1$V1)
  members <- read.csv(file.path(output_path_old,"clstr_enriched1_lib/members_ordered.csv"), header = FALSE)
  reps <- read.csv(file.path(output_path_old,"clstr_enriched1_lib/representatives.csv"), header = FALSE)
  
  
  rep_size_en1 <- data.frame(Representative = reps$V1, Size = sizes_en1$V1)
  rep_size_en1_ordered <- rep_size_en1[order(rep_size_en1$Size, decreasing = T),]
  row.names(rep_size_en1_ordered) <- NULL
  
  counts_en1 <- data.frame(Representative = stringr::str_split(rep_size_en1_ordered$Representative, pattern = "/", simplify = TRUE)[,1], 
                      Enriched1.Count = rep_size_en1_ordered$Size, 
                      Enriched1.Percentage = round((100 * (rep_size_en1_ordered$Size / sum(rep_size_en1_ordered$Size))), 2))
  counts_en1 <- counts_en1 %>% arrange(desc(Enriched1.Count))
  
  counts_all <- plyr::join_all(list(counts_chim, counts_en1), by='Representative', type='full')
  counts_all <- counts_all %>% arrange(desc(Chimeric.Count))
  
  #ratio/ enrichment rate
  counts_all['Ratio_En1Chim'] <- round(counts_all$Enriched1.Percentage / counts_all$Chimeric.Percentage, 2)
  counts_all$Ratio_En1Chim[which(!is.finite(counts_all$Ratio_En1Chim))] <- 0
  
  
  chimeric_orf <- microseq::readFasta(file.path(output_path,"Chimeric_ORF.fasta"))
  names <- as.data.frame(matrix(unlist(stringr::str_split(chimeric_orf$Header, pattern = "/")), 
                                ncol = 5, byrow = TRUE))[[1]]
  chimeric_orf['X'] <- names
  
  counts_all <- dplyr::left_join(counts_all, chimeric_orf[c("X", "Sequence")], by = c("Representative" = "X"))

  write.csv(counts_all, file.path(output_path, "counts.csv"), quote = F, row.names = F)
}

plot.top.reps.in.enrichedlib <- function(counts_file_path, topn_thresh, library_name = ""){
  counts <- read.csv(counts_file_path)
  counts <- counts %>% arrange(desc(Enriched1.Count))
  fig <- plotly::plot_ly(x = counts[1:30, "Enriched1.Count"] , y = counts[1:30, "Representative"], type = 'bar') 
  fig <- fig %>% layout(title= list(text = paste0("Top ", topn_thresh, " representative sequences after clustering \n", library_name)),  
                        xaxis = list(title = 'Number of reads in the cluster'),
                        yaxis = list(title = list(text ='Representative sequence'), 
                                     categoryorder = "array",
                                     categoryarray = ~counts$Representative)
  )
  print(fig)
}


plot.top.reps.in.enrichedlib.ggplot <- function(counts_file_path, topn_thresh, library_name = ""){
  counts <- read.csv(counts_file_path)
  counts <- counts %>% arrange(desc(Enriched1.Count))
  counts <- counts[1:30,]
  level_order <- counts[, 'Representative']
  
  p <- ggplot2::ggplot(data=counts, 
                       aes(x=counts[1:30, "Enriched1.Count"], 
                           y=factor(counts[1:30, "Representative"], levels = level_order), 
                           order=Enriched1.Count)) +
    geom_bar(stat="identity")+
    geom_text(aes(label=Enriched1.Count), hjust=-0.2, size=2.5) +
    labs(title=paste0("Top ", topn_thresh, " representative sequences after clustering \n", library_name), 
         x = 'Number of reads in the cluster', 
         y = 'Representative sequence') +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5)) #+
    #theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 5)) 
  print(p)
}


filter.enriched.reduced.reps <- function(counts_file_path, output_path, enriched_chim_thresh, enriched_ratio_thresh, reduced_chim_thresh, reduced_ratio_thresh){
  counts <- read.csv(counts_file_path)
  
  enriched <- counts[counts$Chimeric.Percentage >= enriched_chim_thresh & counts$Ratio_En1Chim >= enriched_ratio_thresh,]
  enriched <- enriched[order(enriched$Ratio_En1Chim, decreasing = T),]
  rownames(enriched) <- NULL
  
  reduced <- counts[counts$Chimeric.Percentage >= reduced_chim_thresh & counts$Ratio_En1Chim < reduced_ratio_thresh,]
  #reduced <- na.omit(reduced) 
  reduced <- reduced[order(reduced$Ratio_En1Chim, decreasing = T),]
  rownames(reduced) <- NULL
  
  write.csv(enriched, file.path(output_path, "enriched_representatives.csv"), quote = F, row.names = F)
  write.csv(reduced, file.path(output_path, "reduced_representatives.csv"), quote = F, row.names = F)
  
  enriched_fa <- enriched[c("Representative", "Sequence")]
  # limit max 20 sequences
  enriched_fa <- enriched_fa[enriched_fa$Representative %in% enriched[1:min(nrow(enriched), 20),]$Representative,]
  colnames(enriched_fa) <- c("Header", "Sequence")
  microseq::writeFasta(enriched_fa, file.path(output.dir, "files/enriched_representatives.fasta"))
  
  reduced_fa <- reduced[c("Representative", "Sequence")]
  # limit max 20 sequences
  reduced_fa <- reduced_fa[reduced_fa$Representative %in% reduced[1:min(nrow(reduced), 20),]$Representative,]
  colnames(reduced_fa) <- c("Header", "Sequence")
  microseq::writeFasta(reduced_fa, file.path(output.dir, "files/reduced_representatives.fasta"))
  
  out <- list(enriched, reduced)
  return(out)
}

plot.enrichment.tiles <- function(enriched, reduced, type = "Enriched", axis_text_size = 6){
  if (type == "Enriched"){
    counts_filtered = enriched
    counts_filtered_other = reduced
  } else if (type == "Reduced"){
    counts_filtered = reduced
    counts_filtered_other = enriched
  } else {
    cat("\nPlease provide valid type: enriched or reduced.")
  }
  
  level_order <- counts_filtered[order(counts_filtered$Ratio_En1Chim, decreasing = F), 'Representative']
  mid = (round(min(min(counts_filtered$Chimeric.Percentage), min(counts_filtered_other$Chimeric.Percentage),
                   min(counts_filtered$Enriched1.Percentage), min(counts_filtered_other$Enriched1.Percentage)) +
                 max(max(counts_filtered$Chimeric.Percentage), max(counts_filtered_other$Chimeric.Percentage),
                     max(counts_filtered$Enriched1.Percentage), max(counts_filtered_other$Enriched1.Percentage)))+1)/2
  
  ggp1 <- ggplot(counts_filtered, aes(factor(Representative, level = level_order), "")) +    
    geom_tile(aes(fill = Chimeric.Percentage, height = 1)) +
    geom_text(aes(label = Chimeric.Percentage)) + 
    scale_fill_gradient2(low = "#1b98e0", mid = "white", high = "#EE4B2B", 
                         midpoint = mid,
                         name = "Chim[%]") +
    ylab("") +
    xlab("") +  
    ggtitle(paste0(type, " representative sequences after clustering \nRatio = Enriched 1/Chimeric")) + 
    theme_bw() +
    theme(axis.ticks.y = element_blank(), axis.text=element_text(size=axis_text_size), plot.title = element_text(hjust = 0.5)) +
    guides(fill = guide_colourbar(barwidth = 0.5, barheight = 5.5))
  
  
  ggp2 <- ggplot(counts_filtered, aes(factor(Representative, level = level_order), "")) +    
    geom_tile(aes(fill = Enriched1.Percentage, height = 1)) +
    geom_text(aes(label = Enriched1.Percentage)) + 
    scale_fill_gradient2(low = "#1b98e0", mid = "white", high = "#EE4B2B", 
                         midpoint = mid,
                         name = "En1[%]") +
    ylab("") +
    xlab("") +  
    theme_bw() +
    theme(axis.ticks.y = element_blank(), axis.text=element_text(size=axis_text_size), plot.title = element_text(hjust = 0.5)) +
    guides(fill = guide_colourbar(barwidth = 0.5, barheight = 5.5))
  
  
  ggp3 <- ggplot(counts_filtered, aes(factor(Representative, level = level_order), "")) +    
    geom_tile(aes(fill = Ratio_En1Chim, height = 1)) +
    geom_text(aes(label = Ratio_En1Chim)) + 
    scale_fill_gradient2(low = "#1b98e0", mid = "white", high = "#EE4B2B", 
                         midpoint = (min(min(counts_filtered$Ratio_En1Chim), min(counts_filtered_other$Ratio_En1Chim)) + 
                                       max(max(counts_filtered$Ratio_En1Chim), max(counts_filtered_other$Ratio_En1Chim)))/2, 
                         name = "Ratio") +
    ylab("") +
    xlab("") +  
    theme_bw() +
    theme(axis.ticks.y = element_blank(), axis.text=element_text(size=axis_text_size), plot.title = element_text(hjust = 0.5)) +
    guides(fill = guide_colourbar(barwidth = 0.5, barheight = 5.5))
  
  

  print(cowplot::plot_grid(ggp1, ggp2, ggp3, align = "hv", ncol = 1))
  
}


# helper functions called in get.conserved.positions()
# function which finds the ranges given list of numbers
findRanges_helper <- function(run){
  rundiff <- c(1, diff(run))
  difflist <- split(run, cumsum(rundiff!=1))
  unlist(lapply(difflist, function(x){
    if(length(x) == 1) as.character(x) else paste0(x[1], "-", x[length(x)]) #length(x) == 1:2
  }), use.names=FALSE)
}

#duplicate single positions
dup_helper <- function(x) {
  if(length(x) == 1) {
    x = rep(x, 2)
  } else {
    x = x
  }
}

get.conserved.positions <- function(aln_file_path, format = "clustal"){
  alignment <- seqinr::read.alignment(aln_file_path, format = format, forceToLower = F)
  alignment$seq <- gsub("[\r\n\t]", "", alignment$seq)
  
  conn <- file(aln_file_path, open="r")
  linn <- readLines(conn)
  close(conn)
  
  #remove not needed lines
  linn <- linn[which(!(startsWith(linn, "CLUSTAL") | linn == ""))]
  
  #get identity pattern line
  identity_pattern = ""
  name_plus_6 <- max(nchar(alignment$nam)) + 6     #name with max length + 6 spaces
  for (i in seq(alignment$nb + 1, length(linn), alignment$nb + 1)){
    identity_pattern = paste0(identity_pattern, substring(linn[i], name_plus_6 + 1, nchar(linn[i])))
  }
  
  #find positions of * : . these symbols in identity_pattern string
  identity_symbol_idx  <- lapply(strsplit(identity_pattern, ''), 
                                 function(x) which(x == '*' | x == ":" | x == "."))
  identity_symbol_idx <- unlist(identity_symbol_idx)
  
  
  #get the ranges where there are identity symbols
  identity_ranges <- findRanges_helper(identity_symbol_idx)
  
  #remove single positions
  #identity_ranges = identity_ranges[unlist(lapply(identity_ranges, function(x) grepl("-", x)))]
  
  #split by - to separate start and end positions
  identity_ranges_splitted <- str_split(identity_ranges, pattern = "-")
  

  identity_ranges_splitted <- lapply(identity_ranges_splitted, dup_helper)
  
  #make dataframe of identity ranges
  identity_ranges_df = as.data.frame(matrix(unlist(identity_ranges_splitted), 
                                            ncol = 2, byrow = TRUE))
  colnames(identity_ranges_df) = c("start_nt", "end_nt")
  identity_ranges_df$start_nt = as.integer(identity_ranges_df$start_nt)
  identity_ranges_df$end_nt = as.integer(identity_ranges_df$end_nt)

  out = list(identity_ranges_df, alignment)
  return(out)
}



add.gap.info <- function(alignment, nj_matrix, step_size ){
  aln_length <- nchar(alignment$seq[1])
  #split to characters
  aln_seq <- lapply(alignment$seq , function(y) unlist(strsplit(y, '')))
  aln_seq <- lapply(aln_seq, unlist)
  
  #gap positions in alignment sequences
  aln_gap_positions  <- lapply(aln_seq, 
                               function(x) which(x == '-'))
  
  aln_all_positions <- seq_len(aln_length) 
  
  aln_not_gap_positions <- lapply(aln_gap_positions, 
                                  function(x) setdiff(aln_all_positions, x))
  
  fun <- function(gap_i, not_gap_i, name_i){
    l <- c()
    l[gap_i] <- 18
    j = 0
    for (i in seq_len(length(nj_matrix[name_i, ][nj_matrix[name_i, ] != 18]))){ 
      ng_idx <- not_gap_i[(j + 1):min(length(not_gap_i), (j+step_size))]   #read_length for no overlap
      l[ng_idx] <- nj_matrix[name_i, i]
      j = j + step_size
    }
    return(l)
  }
  
  list_all_nt <- mapply(fun, gap_i = aln_gap_positions, not_gap_i = aln_not_gap_positions, name_i = alignment$nam, SIMPLIFY = F)
  
  matrix_nt <- matrix(as.numeric(unlist(list_all_nt)), nrow = alignment$nb, byrow = TRUE)
  rownames(matrix_nt) <- alignment$nam
  
  return(matrix_nt)
}



#VP positions from https://www.ncbi.nlm.nih.gov/nuccore/110645916
plot.vp.positions <- function(){
  p <- ggplot() + 
        geom_segment(aes(x=1,xend=2208,y=2.5,yend=2.5), color = "blue", size=1.5) + #	2,203..4,410 Length:	2208 nt
        geom_segment(aes(x=412,xend=2208,y=2,yend=2), color = "green", size=1.5) + #2,614..4,410 Length:	1,797 nt
        geom_segment(aes(x=607,xend=2208,y=1.5,yend=1.5), color = "red", size=1.5) + #2,809..4,410 Length:	1,602 nt
        geom_hline(yintercept = 1, color = "white") + 
        geom_hline(yintercept = 3, color = "white") + 
        annotate("text", x = -61, y = 2.5, label = "VP1") +
        annotate("text", x = 352, y = 2, label = "VP2") +
        annotate("text", x = 547, y = 1.5, label = "VP3") +
        theme_classic() +
        xlab("") + ylab("") + 
        theme(axis.text.y=element_blank(),
              axis.ticks.y=element_blank(),
              axis.line.y=element_blank()
        )
  print(p)
}


get.reps.nj.matrix.nt <- function(output_path, path_fasta){
  data <- microseq::readFasta(path_fasta)
  col_num <- max(nchar(data$Sequence))
  fun <- function(name_i){
    positions <- seq_len(nchar(data[sub("/ORF.*", "", data$Header) == name_i,]$Sequence))
    l <- c()
    j = 0
    for (i in seq_len(length(reps_nj_mat[name_i, ][reps_nj_mat[name_i, ] != 18]))){
      idx <- positions[(j + 1):min(length(positions), (j+step_size))]
      l[idx] <- reps_nj_mat[name_i, i]
      j = j + step_size
    }
    l <- c(l, rep(18, col_num - length(l)))
    return(l)
  }
  
  list_all_nt <- lapply(rownames(reps_nj_mat), fun)
  reps_nj_mat_nt <- matrix(as.numeric(unlist(list_all_nt)), nrow = nrow(reps_nj_mat), byrow = TRUE)
  rownames(reps_nj_mat_nt) <- rownames(reps_nj_mat)
  
  seq_labels <- c()
  for (i in list_all_nt){
    seq_label <- paste(i, collapse = " ")
    seq_labels <- c(seq_labels, seq_label)
  }
  
  #comp <- lapply(list_all_nt, function(x) paste(x, collapse = " "))
  chimeric_rep_predicted_labels <- data.frame(X = rownames(reps_nj_mat), 
                                              composition = seq_labels)
  write.csv(chimeric_rep_predicted_labels, file.path(output_path, "Chimeric_rep_predicted_labels.csv"), row.names = F, quote = F)
  
}
```


Hafoe pipeline

```{r}
# rdata_name <- paste0("./", output.dir, ".RData")

# Appending the log file
#######################################################################################
#######################################################################################

# log_file <- file(file.path(output.dir, "log/hafoe.log"), open = "wt")
# sink(log_file, append = T, type = "output") 
# sink(log_file, append = T, type = "message")

# Checking and installing dependencies
#######################################################################################
#######################################################################################

cat("\nChecking and installing dependencies\n")
cat("===================================================================\n\n")


# If a package is installed, it will be loaded. If any
# are not, the missing package(s) will be installed
# and then loaded.

# First specify the packages of interest
packages = c("dplyr", "ORFik", "plotly", "ggplot2", "gplots",
             "microseq", "Biostrings", "stringr", "cowplot", "seqinr")


# Now load or install&load all
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!suppressPackageStartupMessages(require(x, character.only = TRUE, quietly = T))) {
      install.packages(x, dependencies = TRUE)
      suppressPackageStartupMessages(library(x, character.only = TRUE, quietly = T))
    }
  }
)


cat("Following R packages were installed and/or called:\n")
cat(paste0("\tdplyr: version ", packageVersion("dplyr"), "\n"))
cat(paste0("\tORFik: version ", packageVersion("ORFik"), "\n"))
cat(paste0("\tplotly: version ", packageVersion("plotly"), "\n"))
cat(paste0("\tggplot2: version ", packageVersion("ggplot2"), "\n"))
cat(paste0("\tgplots: version ", packageVersion("gplots"), "\n"))
cat(paste0("\tmicroseq: version ", packageVersion("microseq"), "\n"))
cat(paste0("\tBiostrings: version ", packageVersion("Biostrings"), "\n"))
cat(paste0("\tstringr: version ", packageVersion("stringr"), "\n"))
cat(paste0("\tcowplot: version ", packageVersion("cowplot"), "\n"))
cat(paste0("\tseqinr: version ", packageVersion("seqinr"), "\n"))


# Check what part of the program to run
#######################################################################################
#######################################################################################

if (explore) {


  # Read input variables
  #######################################################################################
  #######################################################################################

  parent_serotypes <- microseq::readFasta(parent.path)

  chimeric_library <- read.csv(chimeric.lib.path) #should contain columns: X (name), Sequence, Count      
  if (any(chimeric_library$X == "")){
    # Handle missing names
    index <- c(1:nrow(chimeric_library))
    chimeric_library[, "index"] <- index
    chimeric_library[, "X"] = paste0("AAV.", 100000 + as.numeric(chimeric_library$index))
  }


  chimeric_library_fa <- chimeric_library[c('X', 'Sequence')]
  colnames(chimeric_library_fa) <- c("Header", "Sequence")
  chimeric_library_fa.path <- paste0(sub('\\..[^\\.]*$', '', chimeric.lib.path), ".fasta")
  # microseq::writeFasta(chimeric_library_fa, chimeric_library_fa.path)


  # Pre-processing, filtering, general info
  #######################################################################################
  #######################################################################################

  
  # Filter by ORF length >= min_orf (600 aa) and sequence length <= max_seq(3000 nt)
  # ORF, Variant length distribution after filtering
  #######################################################################################
  #######################################################################################
  dir.create(output.dir, showWarnings=F)
  dir.create(file.path(output.dir, "files"), showWarnings = F)


  cat("\n\nFiltering the input libraries by ORF and original sequence lengths\n")
  cat("===================================================================\n\n")
  cat("Filtering the chimeric library\n")
  cat("-------------------------------------------------------------------\n")


  # Chimeric library
  out_chim <- filter.by.orf(chimeric_library_fa,
                            chimeric_library_fa.path,
                            library_name = "Chimeric")
  fasta_orf_filtered_chim <- out_chim[[1]]
  fasta_orf_seq_filtered_chim <- out_chim[[2]]

  p4 <- plot.histogram(fasta_orf_filtered_chim$Sequence,
                       "Chimeric",
                       "variant",
                       additional_info = "\nafter filtering")
  p5 <- plot.histogram(fasta_orf_seq_filtered_chim$Sequence,
                       "Chimeric",
                       "ORF",
                       additional_info = "\nafter filtering")

  #Enriched1 library
  if (!(is.na(en1.path) || en1.path == '' || is.null(en1.path))) {
    cat("Filtering the enrichment cycle 1 library\n")
    cat("-------------------------------------------------------------------\n")

    enriched1 <- microseq::readFastq(en1.path)
    enriched1$Header <- gsub("/", ".", enriched1$Header)
    out_e1 <- filter.by.orf(file = enriched1, 
                            file_path = en1.path,
                            library_name = "Enriched1",
                            format = "fastq")
    fasta_orf_filtered_e1 <- out_e1[[1]]
    fasta_orf_seq_filtered_e1 <- out_e1[[2]]

    p6 <- plot.histogram(fasta_orf_filtered_e1$Sequence,
                         "Enriched1",
                         "variant",
                         additional_info = "\nafter filtering")
    p7 <- plot.histogram(fasta_orf_seq_filtered_e1$Sequence,
                         "Enriched1",
                         "ORF",
                         additional_info = "\nafter filtering")
  }


  # Clustering filtered chimeric library
  #######################################################################################
  #######################################################################################

  cat("\n\nClustering the filtered chimeric library\n")
  cat("===================================================================\n\n")
  cat("Program: cd-hit-est\n")


  dir.create(file.path(output.dir, "files/clstr_chimeric_lib"), showWarnings = F)
  # 
  # o <- system(paste0(file.path(scripts.dir, "clustering.sh"),
  #               " -h ", cd_hit_est.path,
  #               " -i ", file.path(output.dir, "files", paste0("Chimeric", "_ORF.fasta")),
  #               " -o ", file.path(output.dir, "files/clstr_chimeric_lib"),
  #               " -p ", "clstr_chim.fasta ",
  #               " -l ", file.path(output.dir, "log/cd_hit_est.log"),
  #               " -c ", 0.90,  
  #               " -n ", 9,
  #               " -g ", 0,
  #               " -a ", 0.90),
  #         intern = TRUE) #to capture the output of the command as an R character vector
  # cat(o, sep = "\n")


  cluster_sizes <- read.csv(file.path(output.dir.old, "files/clstr_chimeric_lib/cluster_sizes.csv"), header = F)


  cat(paste0("\nNumber of clusters: ", nrow(cluster_sizes), "\n"))
  cat(paste0("Cluster size summary statistics\n"))
  print(summary(cluster_sizes$V1))



  # Choose representatives
  #######################################################################################
  #######################################################################################

  cat("\n\nChoosing new representative sequences for the clusters\n")
  cat("===================================================================\n\n")

  cluster_members <- choose.new.representatives(sizes_path = file.path(output.dir.old, "files/clstr_chimeric_lib/cluster_sizes.csv"),
                                               members_path = file.path(output.dir.old, "files/clstr_chimeric_lib/members_ordered.csv"),
                                               chimeric_library = chimeric_library,
                                               fasta_orf_seq_filtered_chim = fasta_orf_seq_filtered_chim,
                                               fasta_path = file.path(output.dir, "files/clstr_chimeric_lib/clstr_chim_new.fasta"),
                                               csv_path = file.path(output.dir, "files/clstr_chimeric_lib/representatives.csv"))

  cat("\n\nPlotting the cluster size distribution\n")
  cat("===================================================================\n\n")

  #FIGURE 2 of the paper
  dir.create(file.path(output.dir, "reports"), showWarnings = F)

  cat(paste0("Output path: ", file.path(output.dir, "reports/cluster_size_distr_chimeric_lib.pdf"), "\n"))

  graphics.off()
  pdf(file.path(output.dir, "reports/cluster_size_distr_chimeric_lib.pdf"), width=8, height=5)
  plot.cluster.size.distribution(cluster_members = cluster_members,
                                 size_thresh = 45,
                                 library_name = "chimeric library")
  dev.off()

  
  #This part requeires external tools
  #Index parental AAV file
  #######################################################################################
  #######################################################################################

  # cat("\n\nBuilding index on parental library\n")
  # cat("===================================================================\n\n")


  # dir.create(file.path(output.dir, "files/parent_index"), showWarnings = F)
  # 
  # o <- system(paste0(file.path(scripts.dir, "index.sh"),
  #                     " -b ", bowtie.build.path,
  #                     " -i ", parent.path,
  #                     " -o ", file.path(output.dir, "files/parent_index"),
  #                     " -p ", "AAV",
  #                     " -l ", file.path(output.dir, "log/bowtie_build.log")),
  #             intern = TRUE)
  # cat(o, sep = "\n")



  # Variant description of chimeric library representatives
  #######################################################################################
  #######################################################################################

  # cat("\n\nDoing variant description on chimeric library representatives\n")
  # cat("===================================================================\n")
  # 
  # cat("\n\nMaking fastq files for chimeric library representatives\n")
  # cat("-------------------------------------------------------------------\n\n")

  #make fastq files for query sequences
  # make.fastq.files(read_length = read_length,
  #                  fasta.path = file.path(output.dir, "files/clstr_chimeric_lib/clstr_chim_new.fasta"),
  #                  library_name = "chimeric_lib_representatives",
  #                  overlap = overlap,
  #                  step_size = step_size)
  # 
  # cat("\n\nAligning chimeric library representatives on parental index\n")
  # cat("-------------------------------------------------------------------\n\n")
  # 
  # #do alignment
  # o <- system(paste0(file.path(scripts.dir, "align_strict.sh"),
  #                     " -b ", bowtie.align.path,
  #                     " -d ", file.path(output.dir, "files/variant_description/chimeric_lib_representatives"),
  #                     " -r ", file.path(output.dir, "files/parent_index", "AAV"),
  #                     " -s ", samtools.path,
  #                     " -i ", "fastq",
  #                     " -l ", file.path(output.dir, "log/bowtie_align_representatives.log"),
  #                     " -L ", 30,
  #                     " -D ", 2 ),
  #             intern = T)
  # cat(o, sep = "\n")


  # cat("\n\nGetting required files for variant description\n")
  # cat("-------------------------------------------------------------------\n\n")
  # 
  # #get description files
  # o <- system(paste0(file.path(scripts.dir, "get_description_files.sh"),
  #                    " -d ", file.path(output.dir, "files/variant_description/chimeric_lib_representatives"),
  #                    " -s ", samtools.path),
  #             intern = T)
  # cat(o, sep = "\n")


  
  #Variant description
  
  #list mapping AAV serotypes' accession codes to number
  serotype_name <- c(
    "NC_002077.1",
    "NC_001401.2",  #old "ENA|J01901|J01901.1"
    "ENA|U48704|U48704.1" ,
    "NC_001829.1",
    "NC_006152.1",
    "ENA|AF028704|AF028704.1",
    "ENA|AF513851|AF513851.1",
    "ENA|AAN03857|AAN03857.1",
    "ENA|AAS99264|AAS99264.1",
    "ENA|AAT46337|AAT46337.1",
    "AY631966.1",
    "DQ813647.1",
    "EU285562.1",
    "AY242997.1", #AAVrh8
    "AY243015.1", #AAVrh10
    "AY243003.1") #AAVrh32
  serotype_num <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
  serotypes_df <- data.frame(serotype_name, serotype_num, stringsAsFactors = FALSE)


  
  col = c("#D3D3D3", "#A6CEE3", "#1F78B4", "#B2DF8A", "#555555", "#33A02C",
          "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", "#6A3D9A",
          "#FFFF99", "#B15928", "yellow", "#999999", "#a70000", "black", "white")
  legend_name <- c("no alignment", "AAV1", "AAV2", "AAV3", "AAV4", "AAV5",
                   "AAV6", "AAV7", "AAV8", "AAV9", "AAV10", "AAV11", "AAV12", 
                   "AAV13", "AAVrh8", "AAVrh10", "AAVrh32", "multiple alignment", "gap")
  col_df <- data.frame(col = col)
  rownames(col_df) <- legend_name
  
  
  

  cat("\n\nDoing neighbor-aware serotype identification\n")
  cat("-------------------------------------------------------------------\n\n")

  neighbor.joining(parents_df = serotypes_df,
                   path_fasta = file.path(output.dir, "files/clstr_chimeric_lib/clstr_chim_new.fasta"),
                   path_mapped = file.path(output.dir.old, "files/variant_description/chimeric_lib_representatives/csv/mapped"),
                   path_unmapped = file.path(output.dir.old, "files/variant_description/chimeric_lib_representatives/csv/unmapped"),
                   read_length = read_length,
                   library_name = "chimeric_lib_representatives",
                   overlap = overlap,
                   step_size = step_size)


  #Plot variant description

  reps_nj_mat <- read.table(file.path(output.dir,                                     "files/variant_description/chimeric_lib_representatives/chimeric_lib_representatives_variant_description.csv"))
  rownames(reps_nj_mat) <- reps_nj_mat[,1]
  reps_nj_mat[,1] <- NULL
  reps_nj_mat <- as.matrix(reps_nj_mat)
  colnames(reps_nj_mat)<-NULL

  serotypes_freq <- get.frequency.table(chimeric_library,
                                        nj_matrix = reps_nj_mat,
                                        cluster_members,
                                        output_path = file.path(output.dir, "files"))

  cat("\n\nPlotting the cluster abundance\n")
  cat("===================================================================\n\n")

  cat(paste0("Output path: ", file.path(output.dir, "reports/cluster_abundance_chimeric_lib.pdf"), "\n"))

  graphics.off()
  pdf(file.path(output.dir, "reports/cluster_abundance_chimeric_lib.pdf"), width=8, height=5)
  plot.cluster.abundance(file_path = file.path(output.dir, "files/chimeric_lib_rep_counts.csv"),
                         size_thresh = 45,
                         library_name = "chimeric library")
  dev.off()

  cat("\n\nPlotting variant description of chimeric library representatives\n")
  cat("===================================================================\n\n")
  #FIGURE 4b of the paper
  cat(paste0("Output path: ", file.path(output.dir, "reports/variant_description_chimeric_rep.pdf"), "\n"))

  graphics.off()
  pdf(file.path(output.dir, "reports/variant_description_chimeric_rep.pdf"), width=8, height=5)
  plot.variant.description(matrix = reps_nj_mat, 
                           col_df = col_df,
                           library_name = "chimeric library representatives\n")
  dev.off()
  
  #Part of FIGURE 6 of the paper
  #Plot VP1,2,3 positions
  graphics.off()
  pdf(file.path(output.dir, "reports/viral_proteins_positions.pdf"), width=8, height=1.5)
  plot.vp.positions()
  dev.off()
  
  
  cat("\n\nPlotting distribution of AAV serotypes in chimeric library\nbased on variant description of representatives and their\nabundance the chimeric library\n")
  cat("===================================================================\n\n")

  #FIGURE 3b of the paper
  cat(paste0("Output path: ", file.path(output.dir, "reports/serotype_distribution_chimeric_lib.pdf"), "\n"))

  graphics.off()
  pdf(file.path(output.dir, "reports/serotype_distribution_chimeric_lib.pdf"), width=8, height=5)
  plot.serotype.frequency(serotypes_freq = serotypes_freq,
                          col_df = col_df,
                          library_name = "chimeric library")
  dev.off()

  
  # cat("\n\nCalculate accuracy of variant description on representatives\n")
  # cat("===================================================================\n\n")
  
  get.reps.nj.matrix.nt(output_path = file.path(output.dir, "files"),
                        path_fasta = file.path(output.dir, "files/clstr_chimeric_lib/clstr_chim_new.fasta"))


  
  if(identify) {
    #use also ednriched libs to find abundant variants

    #This part requires external tools
    
    # Clustering enriched library sequences with chimeric library representative sequences
    #######################################################################################
    #######################################################################################

    # cat("\n\nClustering enriched 1 library with chimeric library representatives\n")
    # cat("===================================================================\n\n")
    # cat("Program: cd-hit-est-2d\n")
    # 
    # 
    # dir.create(file.path(output.dir, "files/clstr_enriched1_lib"), showWarnings = F)
    # 
    # o <- system(paste0(file.path(scripts.dir, "clustering_identify.sh"),
    #                    " -h ", cd_hit_est_2d.path,
    #                    " -i ", file.path(output.dir, "files/clstr_chimeric_lib/clstr_chim_new.fasta"),
    #                    " -e ", file.path(output.dir, "files", paste0("Enriched1", "_ORF.fasta")),
    #                    " -o ", file.path(output.dir, "files/clstr_enriched1_lib"),
    #                    " -p ", "clstr_enr1.fasta ",
    #                    " -l ", file.path(output.dir, "log/cd_hit_est_2d_enriched1.log"),
    #                    " -c ", 0.95,
    #                    " -n ", 9,
    #                    " -g ", 0,
    #                    " -a ", 0.95,
    #                    " -m ", 8000),
    #             intern = TRUE) #to capture the output of the command as an R character vector
    # cat(o, sep = "\n")


    cluster_sizes <- read.csv(file.path(output.dir.old, "files/clstr_enriched1_lib/cluster_sizes.csv"), header = F)

    cat(paste0("\nNumber of clusters: ", nrow(cluster_sizes), "\n"))
    cat(paste0("Cluster size summary statistics\n"))
    print(summary(cluster_sizes$V1))
    
    
    cat("\n\nCreating counts.csv summary table for representative enrichment\n")
    cat("===================================================================\n\n")
    cat(paste0("Output path: ", file.path(output.dir, "files/chimeric_lib_rep_counts.csv"), "\n"))
    
    get.counts.table(chim_file_path = file.path(output.dir, "files/chimeric_lib_rep_counts.csv"),
                     output_path_old = file.path(output.dir.old, "files"),
                     output_path = file.path(output.dir, "files"))
    
    cat("\n\nPlotting top representatives' abundance in enriched 1 library\n")
    cat("===================================================================\n\n")
    
    cat(paste0("Output path: ", file.path(output.dir, "reports/top_rep_en1_barplot.pdf"), "\n"))
    
    graphics.off()
    pdf(file.path(output.dir, "reports/top_rep_en1_barplot.pdf"), width=8, height=5)
    plot.top.reps.in.enrichedlib.ggplot(counts_file_path = file.path(output.dir, "files/counts.csv"),
                                         topn_thresh = 30,
                                         library_name = "Enriched 1")
    dev.off()
    
    cat("\n\nFilter enriched, reduced representatives based on En1/Chim ratio\n")
    cat("===================================================================\n\n")
    
    cat(paste0("Output path for enriched: ", file.path(output.dir, "files/enriched_representatives.csv"), "\n"))
    cat(paste0("Output path for reduced: ", file.path(output.dir, "files/reduced_representatives.csv"), "\n"))
    cat(paste0("Output path for reduced: ", file.path(output.dir, "files/enriched_representatives.fasta"), "\n"))
    cat(paste0("Output path for reduced: ", file.path(output.dir, "files/reduced_representatives.fasta"), "\n\n"))
    

    out <- filter.enriched.reduced.reps(counts_file_path = file.path(output.dir, "files/counts.csv"),
                                                   output_path = file.path(output.dir, "files"),
                                                   reduced_chim_thresh = 0.1,
                                                   reduced_ratio_thresh = 1,
                                                   enriched_chim_thresh = 0.5,
                                                   enriched_ratio_thresh = 1)
    enriched = out[[1]]
    reduced = out[[2]]
    
    
    cat(paste0(nrow(enriched), " enriched sequences found.\n"))
    cat(paste0(nrow(reduced), " reduced sequences found.\n"))
    
    
    cat("\n\nPlot enriched, reduced representatives based on En1/Chim ratio\n")
    cat("===================================================================\n\n")
    cat(paste0("Output path for enriched: ", file.path(output.dir, "reports/enriched_reps_en1.pdf"), "\n"))
    cat(paste0("Output path for reduced: ", file.path(output.dir, "reports/reduced_reps_en1.pdf"), "\n"))
    
    #FIGURE 5a of the paper
    graphics.off()
    pdf(file.path(output.dir, "reports/enriched_reps_en1.pdf"), width=12, height=5)
    plot.enrichment.tiles(enriched = enriched[1:min(nrow(enriched), 20),], 
                          reduced = reduced,
                          type = "Enriched") 
                          #axis_text_size = 8)
    dev.off()
    
    #FIGURE 5b of the paper
    reduced <- reduced[order(reduced$Chimeric.Count, decreasing = T),]
    graphics.off()
    pdf(file.path(output.dir, "reports/reduced_reps_en1.pdf"), width=12, height=5)
    plot.enrichment.tiles(enriched = enriched, 
                          reduced = reduced[1:min(nrow(reduced), 20),],
                          type = "Reduced")
    dev.off()
    
    cat("\n\nPlotting variant description of enriched, reduced representatives\n")
    cat("===================================================================\n\n")
    cat(paste0("Output path: ", file.path(output.dir, "reports/variant_description_enriched.pdf"), "\n"))
    cat(paste0("Output path: ", file.path(output.dir, "reports/variant_description_reduced.pdf"), "\n"))
    
    graphics.off()
    pdf(file.path(output.dir, "reports/variant_description_enriched.pdf"), width=8, height=5)
    plot.variant.description(matrix = reps_nj_mat[enriched[1:min(nrow(enriched), 20),]$Representative,],
                             col_df = col_df,
                             library_name = "enriched representative variants\n")
    dev.off()
    
    graphics.off()
    pdf(file.path(output.dir, "reports/variant_description_reduced.pdf"), width=8, height=5)
    plot.variant.description(matrix = reps_nj_mat[reduced[1:min(nrow(reduced), 20),]$Representative,],
                             col_df = col_df,
                             library_name = "reduced representative variants\n")
    
    
    dev.off()

    # This part requires external tools
    # cat("\n\nMultiple sequence alignment of enriched, reduced representatives\n")
    # cat("===================================================================\n\n")
    # cat(paste0("Output path: ", file.path(output.dir, "files/enriched_msa.clustal_num"), "\n"))
    # cat(paste0("Output path: ", file.path(output.dir, "files/reduced_msa.clustal_num"), "\n\n"))
    # 
    # o <- system(paste0(file.path(scripts.dir, "msa.sh"),
    #                    " -c ", clustalo.path,
    #                    " -i ", file.path(output.dir, "files/enriched_representatives.fasta"),
    #                    " -o ", file.path(output.dir, "files/enriched_msa.clustal_num")),
    #             intern = TRUE) 
    # cat(o, sep = "\n\n")
    # 
    # 
    # o <- system(paste0(file.path(scripts.dir, "msa.sh"),
    #                    " -c ", clustalo.path,
    #                    " -i ", file.path(output.dir, "files/reduced_representatives.fasta"),
    #                    " -o ", file.path(output.dir, "files/reduced_msa.clustal_num")),
    #             intern = TRUE) 
    # cat(o, sep = "\n")
    # 
    
    cat("\n\n Get conserved and gap regions from multiple sequence alignment\n")
    cat("===================================================================\n\n")
    cat(paste0("Output path: ", file.path(output.dir, "files/"), "\n"))
    cat(paste0("Output path: ", file.path(output.dir, "files/"), "\n"))
    
    out <- get.conserved.positions(aln_file_path = file.path(output.dir.old, "files/enriched_msa.clustal_num"))
    identity_ranges_enriched <- out[[1]]
    alignment_enriched <- out[[2]]
    
    out <- get.conserved.positions(aln_file_path = file.path(output.dir.old, "files/reduced_msa.clustal_num"))
    identity_ranges_reduced <- out[[1]]
    alignment_reduced <- out[[2]]
    
    matrix_nt_enriched <- add.gap.info(alignment = alignment_enriched, nj_matrix = reps_nj_mat, step_size = step_size) 
    matrix_nt_reduced <- add.gap.info(alignment = alignment_reduced, nj_matrix = reps_nj_mat, step_size = step_size) 
    
    
    #Use AAV2  Variable regions for plot
    aav2_vr_ranges <- data.frame(VR = c("I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"), 
                            start_aa = c(263, 325, 381, 450, 490, 527, 545, 585, 704), 
                            end_aa = c(265, 330, 384, 466, 503, 532, 556, 596, 713))
    aav2_vr_ranges['start_nt'] <- aav2_vr_ranges$start_aa * 3 - 2    #ATGAGGAGC
    aav2_vr_ranges['end_nt'] <- aav2_vr_ranges$end_aa * 3 
    
    cat("\n\nPlot variant description of enriched and reduced representatives\nwith conserved regions and gaps\n")
    cat("===================================================================\n\n")
    cat(paste0("Output path: ", file.path(output.dir, "reports/variant_description_enriched_conserved.pdf"), "\n"))
    cat(paste0("Output path: ", file.path(output.dir, "reports/variant_description_reduced_conserved.pdf"), "\n"))
    
    #FIGURE 6 enriched variants of the paper
    graphics.off()
    pdf(file.path(output.dir, "reports/variant_description_enriched_conserved.pdf"), width=8, height=5)
    # doesn't recognise identity_ranges
    # plot.variant.description.conserved(matrix = matrix_nt_enriched, 
    #                                    identity_ranges = identity_ranges_enriched, 
    #                                    col_df = col_df,
    #                                    library_name = "enriched representative variants")
    ####
    matrix = matrix_nt_enriched
    identity_ranges = identity_ranges_enriched
    col_df = col_df
    library_name = "enriched representative variants\n"
    
    gplots::heatmap.2(matrix, 
                      dendrogram='none', 
                      Colv=FALSE, 
                      Rowv=TRUE, 
                      trace="none", 
                      breaks = seq(-0.5, 18.5, 1),
                      col = col_df$col,
                      key = FALSE, 
                      cexRow=0.7,
                      add.expr = list(rect(xleft = identity_ranges$start_nt, 
                                           xright = identity_ranges$end_nt, 
                                           ybottom = par("usr")[3], ytop = par("usr")[4], 
                                           border = NA, 
                                           col = adjustcolor("blue", alpha = 0.2)),
                                      rect(xleft = aav2_vr_ranges$start_nt,   #VRs
                                           xright = aav2_vr_ranges$end_nt, 
                                           ybottom = par("usr")[3], ytop = par("usr")[4], 
                                           border = NA, #"red", 
                                           density = 20, 
                                           col = adjustcolor("red", alpha = 0.5))))
    
    title(paste0("Variant description of ", library_name), 
          line = -2, 
          adj = 0.6)
    legend(x="bottomleft", 
           legend=rownames(col_df), 
           fill=col_df$col,  
           title = "AAV serotypes", 
           title.adj = 0.2, 
           inset=c(-.07, -.07), 
           xpd=TRUE,
           box.lwd = 0, 
           cex = 0.7)
    
    dev.off()
    
    
    #FIGURE 6 reduced variants of the paper
    graphics.off()
    pdf(file.path(output.dir, "reports/variant_description_reduced_conserved.pdf"), width=8, height=5)
    # plot.variant.description.conserved(matrix = matrix_nt_reduced, 
    #                                    identity_ranges = as.data.frame(identity_ranges_reduced), 
    #                                    col_df = col_df,
    #                                    library_name = "reduced representative variants")
    
    matrix = matrix_nt_reduced
    identity_ranges = as.data.frame(identity_ranges_reduced)
    col_df = col_df
    library_name = "reduced representative variants\n"
    
    gplots::heatmap.2(matrix, 
                      dendrogram='none', 
                      Colv=FALSE, 
                      Rowv=TRUE, 
                      trace="none", 
                      breaks = seq(-0.5, 18.5, 1),
                      col = col_df$col,
                      key = FALSE, 
                      cexRow=0.7,
                      add.expr = list(rect(xleft = identity_ranges$start_nt, 
                                           xright = identity_ranges$end_nt, 
                                           ybottom = par("usr")[3], ytop = par("usr")[4], 
                                           border = NA, 
                                           col = adjustcolor("blue", alpha = 0.2)),
                                      rect(xleft = aav2_vr_ranges$start_nt,   #VRs
                                           xright = aav2_vr_ranges$end_nt, 
                                           ybottom = par("usr")[3], ytop = par("usr")[4], 
                                           border = NA, 
                                           density = 20, 
                                           col = adjustcolor("red", alpha = 0.5))))
    
    title(paste0("Variant description of ", library_name), 
          line = -2, 
          adj = 0.6)
    legend(x="bottomleft", 
           legend=rownames(col_df), 
           fill=col_df$col,  
           title = "AAV serotypes", 
           title.adj = 0.2, 
           inset=c(-.07, -.07), 
           xpd=TRUE,
           box.lwd = 0, 
           cex = 0.7)
    
    dev.off()
    
  }
} else if (identify) {
  cat("\nUse exploreout folder and enriched libs to find abundant variants\n")
  cat("\nNot implemented yet.")
}

# save.image(rdata_name)

#load(rdata_name)

# sink()

```

